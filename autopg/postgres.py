import re
import shutil
import subprocess
from pathlib import Path
from typing import Any

from autopg.constants import PG_CONFIG_DIR, PG_CONFIG_FILE, PG_CONFIG_FILE_BASE


def read_postgresql_conf(base_path: str = PG_CONFIG_DIR) -> dict[str, Any]:
    """Read the postgresql.conf file, preferring .base if it exists"""
    conf_path = Path(base_path) / PG_CONFIG_FILE
    base_conf_path = Path(base_path) / PG_CONFIG_FILE_BASE

    target_path = base_conf_path if base_conf_path.exists() else conf_path
    if not target_path.exists():
        return {}

    config : dict[str, str] = {}
    with target_path.open() as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith("#"):
                try:
                    key, value = line.split("=", 1)
                    config[key.strip()] = value.strip().strip("'")
                except ValueError:
                    continue
    return config


def get_postgres_version() -> int:
    """Get the version of PostgreSQL installed

    Returns:
        int: The major version number of PostgreSQL (e.g. 16 for PostgreSQL 16.3)

    Raises:
        subprocess.CalledProcessError: If postgres is not installed or command fails
        ValueError: If version string cannot be parsed
    """
    try:
        result = subprocess.run(
            ["postgres", "--version"], capture_output=True, text=True, check=True
        )
        version_str = result.stdout.strip()
        # Use regex to find version number pattern (e.g. "16.3" in "postgres (PostgreSQL) 16.3 (Homebrew)")
        version_match = re.search(r"(\d+)\.?\d*", version_str)
        if not version_match:
            raise ValueError("Could not find version number in postgres output")
        return int(version_match.group(1))
    except (subprocess.CalledProcessError, ValueError) as e:
        raise ValueError(f"Failed to get PostgreSQL version: {str(e)}") from e


def format_value(value: int | float | str | bool) -> str:
    """Format configuration values appropriately"""
    if isinstance(value, bool):
        return "true" if value else "false"
    elif isinstance(value, (int, float)):
        return str(value)
    return f"'{value}'"


def write_postgresql_conf(
    config: dict[str, Any], base_path: str = PG_CONFIG_DIR, backup: bool = True
) -> None:
    """Write the postgresql.conf file and optionally backup the old one"""
    conf_path = Path(base_path) / PG_CONFIG_FILE
    base_conf_path = Path(base_path) / PG_CONFIG_FILE_BASE

    # Backup existing config if requested
    if backup and conf_path.exists():
        shutil.copy(conf_path, base_conf_path)

    # Write new config
    with open(conf_path, "w") as f:
        f.write("# Generated by AutoPG\n\n")
        for key, value in sorted(config.items()):
            f.write(f"{key} = {format_value(value)}\n")
