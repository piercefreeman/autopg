import shutil
import subprocess
import re
from pathlib import Path
from typing import Any, Dict, Union


def read_postgresql_conf(base_path: str = "/etc/postgresql") -> Dict[str, Any]:
    """Read the postgresql.conf file, preferring .base if it exists"""
    conf_path = Path(base_path) / "postgresql.conf"
    base_conf_path = Path(base_path) / "postgresql.conf.base"

    target_path = base_conf_path if base_conf_path.exists() else conf_path
    if not target_path.exists():
        return {}

    config = {}
    with open(target_path) as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith("#"):
                try:
                    key, value = line.split("=", 1)
                    config[key.strip()] = value.strip().strip("'")
                except ValueError:
                    continue
    return config

def get_postgres_version() -> int:
    """Get the version of PostgreSQL installed
    
    Returns:
        int: The major version number of PostgreSQL (e.g. 16 for PostgreSQL 16.3)
        
    Raises:
        subprocess.CalledProcessError: If postgres is not installed or command fails
        ValueError: If version string cannot be parsed
    """
    try:
        result = subprocess.run(
            ["postgres", "--version"],
            capture_output=True,
            text=True,
            check=True
        )
        version_str = result.stdout.strip()
        # Use regex to find version number pattern (e.g. "16.3" in "postgres (PostgreSQL) 16.3 (Homebrew)")
        version_match = re.search(r'(\d+)\.?\d*', version_str)
        if not version_match:
            raise ValueError("Could not find version number in postgres output")
        return int(version_match.group(1))
    except (subprocess.CalledProcessError, ValueError) as e:
        raise ValueError(f"Failed to get PostgreSQL version: {str(e)}")

def format_value(value: Union[int, float, str]) -> str:
    """Format configuration values appropriately"""
    if isinstance(value, (int, float)):
        return str(value)
    return f"'{value}'"


def write_postgresql_conf(
    config: Dict[str, Any], base_path: str = "/etc/postgresql", backup: bool = True
) -> None:
    """Write the postgresql.conf file and optionally backup the old one"""
    conf_path = Path(base_path) / "postgresql.conf"
    base_conf_path = Path(base_path) / "postgresql.conf.base"

    # Backup existing config if requested
    if backup and conf_path.exists():
        shutil.copy(conf_path, base_conf_path)

    # Write new config
    with open(conf_path, "w") as f:
        f.write("# Generated by AutoPG\n\n")
        for key, value in sorted(config.items()):
            f.write(f"{key} = {format_value(value)}\n")
